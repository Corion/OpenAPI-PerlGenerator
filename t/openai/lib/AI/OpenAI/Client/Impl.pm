package AI::OpenAI::Client::Impl 0.01;
# DO NOT EDIT! This is an autogenerated file.

use 5.020;
use Moo 2;
use experimental 'signatures';
use PerlX::Maybe;
use Carp 'croak';

# These should go into a ::Role
use YAML::PP;
use Mojo::UserAgent;
use Mojo::URL;
use URI::Template;
use Mojo::JSON 'encode_json', 'decode_json';
use OpenAPI::Modern;

use Future::Mojo;
use Future::Queue;

our $SCHEMA_VERSION = "2.0.0";

use AI::OpenAI::AssistantObject;
use AI::OpenAI::AssistantToolsCode;
use AI::OpenAI::AssistantToolsFileSearch;
use AI::OpenAI::AssistantToolsFunction;
use AI::OpenAI::AssistantsApiResponseFormat;
use AI::OpenAI::AssistantsNamedToolChoice;
use AI::OpenAI::Batch;
use AI::OpenAI::BatchRequestInput;
use AI::OpenAI::BatchRequestOutput;
use AI::OpenAI::ChatCompletionFunctionCallOption;
use AI::OpenAI::ChatCompletionFunctions;
use AI::OpenAI::ChatCompletionMessageToolCall;
use AI::OpenAI::ChatCompletionMessageToolCallChunk;
use AI::OpenAI::ChatCompletionNamedToolChoice;
use AI::OpenAI::ChatCompletionRequestAssistantMessage;
use AI::OpenAI::ChatCompletionRequestFunctionMessage;
use AI::OpenAI::ChatCompletionRequestMessageContentPartImage;
use AI::OpenAI::ChatCompletionRequestMessageContentPartText;
use AI::OpenAI::ChatCompletionRequestSystemMessage;
use AI::OpenAI::ChatCompletionRequestToolMessage;
use AI::OpenAI::ChatCompletionRequestUserMessage;
use AI::OpenAI::ChatCompletionResponseMessage;
use AI::OpenAI::ChatCompletionStreamOptions;
use AI::OpenAI::ChatCompletionStreamResponseDelta;
use AI::OpenAI::ChatCompletionTokenLogprob;
use AI::OpenAI::ChatCompletionTool;
use AI::OpenAI::CompletionUsage;
use AI::OpenAI::CreateAssistantRequest;
use AI::OpenAI::CreateChatCompletionFunctionResponse;
use AI::OpenAI::CreateChatCompletionImageResponse;
use AI::OpenAI::CreateChatCompletionRequest;
use AI::OpenAI::CreateChatCompletionResponse;
use AI::OpenAI::CreateChatCompletionStreamResponse;
use AI::OpenAI::CreateCompletionRequest;
use AI::OpenAI::CreateCompletionResponse;
use AI::OpenAI::CreateEmbeddingRequest;
use AI::OpenAI::CreateEmbeddingResponse;
use AI::OpenAI::CreateFileRequest;
use AI::OpenAI::CreateFineTuningJobRequest;
use AI::OpenAI::CreateImageEditRequest;
use AI::OpenAI::CreateImageRequest;
use AI::OpenAI::CreateImageVariationRequest;
use AI::OpenAI::CreateMessageRequest;
use AI::OpenAI::CreateModerationRequest;
use AI::OpenAI::CreateModerationResponse;
use AI::OpenAI::CreateRunRequest;
use AI::OpenAI::CreateSpeechRequest;
use AI::OpenAI::CreateThreadAndRunRequest;
use AI::OpenAI::CreateThreadRequest;
use AI::OpenAI::CreateTranscriptionRequest;
use AI::OpenAI::CreateTranscriptionResponseJson;
use AI::OpenAI::CreateTranscriptionResponseVerboseJson;
use AI::OpenAI::CreateTranslationRequest;
use AI::OpenAI::CreateTranslationResponseJson;
use AI::OpenAI::CreateTranslationResponseVerboseJson;
use AI::OpenAI::CreateVectorStoreFileBatchRequest;
use AI::OpenAI::CreateVectorStoreFileRequest;
use AI::OpenAI::CreateVectorStoreRequest;
use AI::OpenAI::DeleteAssistantResponse;
use AI::OpenAI::DeleteFileResponse;
use AI::OpenAI::DeleteMessageResponse;
use AI::OpenAI::DeleteModelResponse;
use AI::OpenAI::DeleteThreadResponse;
use AI::OpenAI::DeleteVectorStoreFileResponse;
use AI::OpenAI::DeleteVectorStoreResponse;
use AI::OpenAI::DoneEvent;
use AI::OpenAI::Embedding;
use AI::OpenAI::Error;
use AI::OpenAI::ErrorEvent;
use AI::OpenAI::ErrorResponse;
use AI::OpenAI::FineTuningIntegration;
use AI::OpenAI::FineTuningJob;
use AI::OpenAI::FineTuningJobCheckpoint;
use AI::OpenAI::FineTuningJobEvent;
use AI::OpenAI::FunctionObject;
use AI::OpenAI::FunctionParameters;
use AI::OpenAI::Image;
use AI::OpenAI::ListAssistantsResponse;
use AI::OpenAI::ListBatchesResponse;
use AI::OpenAI::ListFilesResponse;
use AI::OpenAI::ListFineTuningJobCheckpointsResponse;
use AI::OpenAI::ListFineTuningJobEventsResponse;
use AI::OpenAI::ListModelsResponse;
use AI::OpenAI::ListPaginatedFineTuningJobsResponse;
use AI::OpenAI::ListRunsResponse;
use AI::OpenAI::MessageContentImageFileObject;
use AI::OpenAI::MessageContentImageUrlObject;
use AI::OpenAI::MessageContentTextAnnotationsFileCitationObject;
use AI::OpenAI::MessageContentTextAnnotationsFilePathObject;
use AI::OpenAI::MessageContentTextObject;
use AI::OpenAI::MessageDeltaContentImageFileObject;
use AI::OpenAI::MessageDeltaContentImageUrlObject;
use AI::OpenAI::MessageDeltaContentTextAnnotationsFileCitationObject;
use AI::OpenAI::MessageDeltaContentTextAnnotationsFilePathObject;
use AI::OpenAI::MessageDeltaContentTextObject;
use AI::OpenAI::MessageDeltaObject;
use AI::OpenAI::MessageObject;
use AI::OpenAI::MessageRequestContentTextObject;
use AI::OpenAI::ModifyAssistantRequest;
use AI::OpenAI::ModifyMessageRequest;
use AI::OpenAI::ModifyRunRequest;
use AI::OpenAI::ModifyThreadRequest;
use AI::OpenAI::RunCompletionUsage;
use AI::OpenAI::RunObject;
use AI::OpenAI::RunStepCompletionUsage;
use AI::OpenAI::RunStepDeltaObject;
use AI::OpenAI::RunStepDeltaStepDetailsMessageCreationObject;
use AI::OpenAI::RunStepDeltaStepDetailsToolCallsCodeObject;
use AI::OpenAI::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject;
use AI::OpenAI::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject;
use AI::OpenAI::RunStepDeltaStepDetailsToolCallsFileSearchObject;
use AI::OpenAI::RunStepDeltaStepDetailsToolCallsFunctionObject;
use AI::OpenAI::RunStepDeltaStepDetailsToolCallsObject;
use AI::OpenAI::RunStepDetailsMessageCreationObject;
use AI::OpenAI::RunStepDetailsToolCallsCodeObject;
use AI::OpenAI::RunStepDetailsToolCallsCodeOutputImageObject;
use AI::OpenAI::RunStepDetailsToolCallsCodeOutputLogsObject;
use AI::OpenAI::RunStepDetailsToolCallsFileSearchObject;
use AI::OpenAI::RunStepDetailsToolCallsFunctionObject;
use AI::OpenAI::RunStepDetailsToolCallsObject;
use AI::OpenAI::RunStepObject;
use AI::OpenAI::RunToolCallObject;
use AI::OpenAI::SubmitToolOutputsRunRequest;
use AI::OpenAI::ThreadObject;
use AI::OpenAI::TranscriptionSegment;
use AI::OpenAI::TranscriptionWord;
use AI::OpenAI::TruncationObject;
use AI::OpenAI::UpdateVectorStoreRequest;
use AI::OpenAI::VectorStoreExpirationAfter;
use AI::OpenAI::VectorStoreFileBatchObject;
use AI::OpenAI::VectorStoreFileObject;
use AI::OpenAI::VectorStoreObject;

=encoding utf8

=head1 SYNOPSIS

=head1 PROPERTIES

=head2 B<< openapi >>

The L<OpenAPI::Modern> object we use for validation

=head2 B<< ua >>

The L<Mojo::UserAgent> to use

=head2 B<< server >>

The server to access

=cut

# XXX this should be more configurable, and potentially you don't want validation?!

has 'schema_file' => (
    is => 'ro',
);

has 'schema' => (
    is => 'lazy',
    default => sub {
        if( my $fn = $_[0]->schema_file ) {
            YAML::PP->new( boolean => 'JSON::PP' )->load_file( $fn );
        }
    },
);

has 'openapi' => (
    is => 'lazy',
    default => sub { OpenAPI::Modern->new( openapi_schema => $_[0]->schema, openapi_uri => '' )},
);

# The HTTP stuff should go into a ::Role I guess
has 'ua' => (
    is => 'lazy',
    default => sub { Mojo::UserAgent->new },
);

has 'server' => (
    is => 'lazy',
    default => sub { 'https://api.openai.com/v1' },
);

=head1 METHODS

=head2 C<< listAssistants >>

  my $res = $client->listAssistants()->get;

Returns a list of assistants.

=head3 Parameters

=over 4

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=back


Returns a L<< AI::OpenAI::ListAssistantsResponse >> on success.

=cut

sub _build_listAssistants_request( $self, %options ) {
    my $method = 'GET';
    my $path = '/assistants';
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listAssistants( $self, %options ) {
    my $tx = $self->_build_listAssistants_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListAssistantsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createAssistant >>

  my $res = $client->createAssistant()->get;

Create an assistant with a model and instructions.


=head3 Options

=over 4

=item C<< description >>

The description of the assistant. The maximum length is 512 characters.

=item C<< instructions >>

The system instructions that the assistant uses. The maximum length is 256,000 characters.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< model >>

ID of the model to use. You can use the L<List models|/docs/api-reference/models/list> API to see all of your available models, or see our L<Model overview|/docs/models/overview> for descriptions of them.

=item C<< name >>

The name of the assistant. The maximum length is 256 characters.

=item C<< response_format >>

Specifies the format that the model must output. Compatible with L<GPT-4o|/docs/models/gpt-4o>, L<GPT-4 Turbo|/docs/models/gpt-4-turbo-and-gpt-4>, and all GPT-3.5 Turbo models since C<gpt-3.5-turbo-1106>.

Setting to C<{ "type": "json_object" }> enables JSON mode, which guarantees the message the model generates is valid JSON.

B<Important:> when using JSON mode, you B<must> also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if C<finish_reason="length">, which indicates the generation exceeded C<max_tokens> or the conversation exceeded the max context length.

=item C<< temperature >>

What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.

=item C<< tool_resources >>

A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the C<code_interpreter> tool requires a list of file IDs, while the C<file_search> tool requires a list of vector store IDs.

=item C<< tools >>

A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types C<code_interpreter>, C<file_search>, or C<function>.

=item C<< top_p >>

An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.

We generally recommend altering this or temperature but not both.

=back

Returns a L<< AI::OpenAI::AssistantObject >> on success.

=cut

sub _build_createAssistant_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/assistants';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateAssistantRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createAssistant( $self, %options ) {
    my $tx = $self->_build_createAssistant_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::AssistantObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteAssistant >>

  my $res = $client->deleteAssistant()->get;

Delete an assistant.

=head3 Parameters

=over 4

=item B<< assistant_id >>

The ID of the assistant to delete.

=back


Returns a L<< AI::OpenAI::DeleteAssistantResponse >> on success.

=cut

sub _build_deleteAssistant_request( $self, %options ) {
    croak "Missing required parameter 'assistant_id'"
        unless exists $options{ 'assistant_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/assistants/{assistant_id}' );
    my $path = $template->process(
              'assistant_id' => delete $options{'assistant_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteAssistant( $self, %options ) {
    my $tx = $self->_build_deleteAssistant_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteAssistantResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getAssistant >>

  my $res = $client->getAssistant()->get;

Retrieves an assistant.

=head3 Parameters

=over 4

=item B<< assistant_id >>

The ID of the assistant to retrieve.

=back


Returns a L<< AI::OpenAI::AssistantObject >> on success.

=cut

sub _build_getAssistant_request( $self, %options ) {
    croak "Missing required parameter 'assistant_id'"
        unless exists $options{ 'assistant_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/assistants/{assistant_id}' );
    my $path = $template->process(
              'assistant_id' => delete $options{'assistant_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getAssistant( $self, %options ) {
    my $tx = $self->_build_getAssistant_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::AssistantObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< modifyAssistant >>

  my $res = $client->modifyAssistant()->get;

Modifies an assistant.

=head3 Parameters

=over 4

=item B<< assistant_id >>

The ID of the assistant to modify.

=back


=head3 Options

=over 4

=item C<< description >>

The description of the assistant. The maximum length is 512 characters.

=item C<< instructions >>

The system instructions that the assistant uses. The maximum length is 256,000 characters.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< model >>

ID of the model to use. You can use the L<List models|/docs/api-reference/models/list> API to see all of your available models, or see our L<Model overview|/docs/models/overview> for descriptions of them.

=item C<< name >>

The name of the assistant. The maximum length is 256 characters.

=item C<< response_format >>

Specifies the format that the model must output. Compatible with L<GPT-4o|/docs/models/gpt-4o>, L<GPT-4 Turbo|/docs/models/gpt-4-turbo-and-gpt-4>, and all GPT-3.5 Turbo models since C<gpt-3.5-turbo-1106>.

Setting to C<{ "type": "json_object" }> enables JSON mode, which guarantees the message the model generates is valid JSON.

B<Important:> when using JSON mode, you B<must> also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if C<finish_reason="length">, which indicates the generation exceeded C<max_tokens> or the conversation exceeded the max context length.

=item C<< temperature >>

What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.

=item C<< tool_resources >>

A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the C<code_interpreter> tool requires a list of file IDs, while the C<file_search> tool requires a list of vector store IDs.

=item C<< tools >>

A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types C<code_interpreter>, C<file_search>, or C<function>.

=item C<< top_p >>

An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.

We generally recommend altering this or temperature but not both.

=back

Returns a L<< AI::OpenAI::AssistantObject >> on success.

=cut

sub _build_modifyAssistant_request( $self, %options ) {
    croak "Missing required parameter 'assistant_id'"
        unless exists $options{ 'assistant_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/assistants/{assistant_id}' );
    my $path = $template->process(
              'assistant_id' => delete $options{'assistant_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::ModifyAssistantRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub modifyAssistant( $self, %options ) {
    my $tx = $self->_build_modifyAssistant_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::AssistantObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createSpeech >>

  my $res = $client->createSpeech()->get;

Generates audio from the input text.


=head3 Options

=over 4

=item C<< input >>

The text to generate audio for. The maximum length is 4096 characters.

=item C<< model >>

One of the available L<TTS models|/docs/models/tts>: C<tts-1> or C<tts-1-hd>

=item C<< response_format >>

The format to audio in. Supported formats are C<mp3>, C<opus>, C<aac>, C<flac>, C<wav>, and C<pcm>.

=item C<< speed >>

The speed of the generated audio. Select a value from C<0.25> to C<4.0>. C<1.0> is the default.

=item C<< voice >>

The voice to use when generating the audio. Supported voices are C<alloy>, C<echo>, C<fable>, C<onyx>, C<nova>, and C<shimmer>. Previews of the voices are available in the L<Text to speech guide|/docs/guides/text-to-speech/voice-options>.

=back

Returns a L<< string >> on success.

=cut

sub _build_createSpeech_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/audio/speech';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateSpeechRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/octet-stream',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createSpeech( $self, %options ) {
    my $tx = $self->_build_createSpeech_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/octet-stream' ) {
                my $payload = $resp->body();
                $res->done(
                    $payload

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createTranscription >>

  my $res = $client->createTranscription()->get;

Transcribes audio into the input language.


=head3 Options

=over 4

=item C<< file >>

The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.

=item C<< language >>

The language of the input audio. Supplying the input language in L<ISO-639-1|https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes> format will improve accuracy and latency.

=item C<< model >>

ID of the model to use. Only C<whisper-1> (which is powered by our open source Whisper V2 model) is currently available.

=item C<< prompt >>

An optional text to guide the model's style or continue a previous audio segment. The L<prompt|/docs/guides/speech-to-text/prompting> should match the audio language.

=item C<< response_format >>

The format of the transcript output, in one of these options: C<json>, C<text>, C<srt>, C<verbose_json>, or C<vtt>.

=item C<< temperature >>

The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use L<log probability|https://en.wikipedia.org/wiki/Log_probability> to automatically increase the temperature until certain thresholds are hit.

=item C<< timestamp_granularities_ >>

The timestamp granularities to populate for this transcription. C<response_format> must be set C<verbose_json> to use timestamp granularities. Either or both of these options are supported: C<word>, or C<segment>. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.

=back

Returns Hashref on success.

=cut

sub _build_createTranscription_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/audio/transcriptions';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateTranscriptionRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'multipart/form-data',
        }
        => form => $request->as_hash,
    );

    return $tx
}


sub createTranscription( $self, %options ) {
    my $tx = $self->_build_createTranscription_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    $payload

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createTranslation >>

  my $res = $client->createTranslation()->get;

Translates audio into English.


=head3 Options

=over 4

=item C<< file >>

The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.

=item C<< model >>

ID of the model to use. Only C<whisper-1> (which is powered by our open source Whisper V2 model) is currently available.

=item C<< prompt >>

An optional text to guide the model's style or continue a previous audio segment. The L<prompt|/docs/guides/speech-to-text/prompting> should be in English.

=item C<< response_format >>

The format of the transcript output, in one of these options: C<json>, C<text>, C<srt>, C<verbose_json>, or C<vtt>.

=item C<< temperature >>

The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use L<log probability|https://en.wikipedia.org/wiki/Log_probability> to automatically increase the temperature until certain thresholds are hit.

=back

Returns Hashref on success.

=cut

sub _build_createTranslation_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/audio/translations';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateTranslationRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'multipart/form-data',
        }
        => form => $request->as_hash,
    );

    return $tx
}


sub createTranslation( $self, %options ) {
    my $tx = $self->_build_createTranslation_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    $payload

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listBatches >>

  my $res = $client->listBatches()->get;

List your organization's batches.

=head3 Parameters

=over 4

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=back


Returns a L<< AI::OpenAI::ListBatchesResponse >> on success.

=cut

sub _build_listBatches_request( $self, %options ) {
    my $method = 'GET';
    my $path = '/batches';
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'after' => delete $options{'after'},
        maybe 'limit' => delete $options{'limit'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listBatches( $self, %options ) {
    my $tx = $self->_build_listBatches_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Batch listed successfully.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListBatchesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createBatch >>

  my $res = $client->createBatch()->get;

Creates and executes a batch from an uploaded file of requests


=head3 Options

=over 4

=item C<< completion_window >>

The time frame within which the batch should be processed. Currently only C<24h> is supported.

=item C<< endpoint >>

The endpoint to be used for all requests in the batch. Currently C</v1/chat/completions>, C</v1/embeddings>, and C</v1/completions> are supported. Note that C</v1/embeddings> batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.

=item C<< input_file_id >>

The ID of an uploaded file that contains requests for the new batch.

See L<upload file|/docs/api-reference/files/create> for how to upload a file.

Your input file must be formatted as a L<JSONL file|/docs/api-reference/batch/requestInput>, and must be uploaded with the purpose C<batch>. The file can contain up to 50,000 requests, and can be up to 100 MB in size.

=item C<< metadata >>

Optional custom metadata for the batch.

=back

Returns a L<< AI::OpenAI::Batch >> on success.

=cut

sub _build_createBatch_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/batches';
    my $url = Mojo::URL->new( $self->server . $path );

    my $body = delete $options{ body } // ''; # ??? really? This is an "object"
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createBatch( $self, %options ) {
    my $tx = $self->_build_createBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Batch created successfully.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::Batch->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< retrieveBatch >>

  my $res = $client->retrieveBatch()->get;

Retrieves a batch.

=head3 Parameters

=over 4

=item B<< batch_id >>

The ID of the batch to retrieve.

=back


Returns a L<< AI::OpenAI::Batch >> on success.

=cut

sub _build_retrieveBatch_request( $self, %options ) {
    croak "Missing required parameter 'batch_id'"
        unless exists $options{ 'batch_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/batches/{batch_id}' );
    my $path = $template->process(
              'batch_id' => delete $options{'batch_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub retrieveBatch( $self, %options ) {
    my $tx = $self->_build_retrieveBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Batch retrieved successfully.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::Batch->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< cancelBatch >>

  my $res = $client->cancelBatch()->get;

Cancels an in-progress batch.

=head3 Parameters

=over 4

=item B<< batch_id >>

The ID of the batch to cancel.

=back


Returns a L<< AI::OpenAI::Batch >> on success.

=cut

sub _build_cancelBatch_request( $self, %options ) {
    croak "Missing required parameter 'batch_id'"
        unless exists $options{ 'batch_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/batches/{batch_id}/cancel' );
    my $path = $template->process(
              'batch_id' => delete $options{'batch_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub cancelBatch( $self, %options ) {
    my $tx = $self->_build_cancelBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Batch is cancelling. Returns the cancelling batch's details.
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::Batch->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createChatCompletion >>

  my $res = $client->createChatCompletion()->get;

Creates a model response for the given chat conversation.


=head3 Options

=over 4

=item C<< frequency_penalty >>

Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.

L<See more information about frequency and presence penalties.|/docs/guides/text-generation/parameter-details>

=item C<< function_call >>

Deprecated in favor of C<tool_choice>.

Controls which (if any) function is called by the model.
C<none> means the model will not call a function and instead generates a message.
C<auto> means the model can pick between generating a message or calling a function.
Specifying a particular function via C<{"name": "my_function"}> forces the model to call that function.

C<none> is the default when no functions are present. C<auto> is the default if functions are present.

=item C<< functions >>

Deprecated in favor of C<tools>.

A list of functions the model may generate JSON inputs for.

=item C<< logit_bias >>

Modify the likelihood of specified tokens appearing in the completion.

Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.

=item C<< logprobs >>

Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the C<content> of C<message>.

=item C<< max_tokens >>

The maximum number of L<tokens|/tokenizer> that can be generated in the chat completion.

The total length of input tokens and generated tokens is limited by the model's context length. L<Example Python code|https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken> for counting tokens.

=item C<< messages >>

A list of messages comprising the conversation so far. L<Example Python code|https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models>.

=item C<< model >>

ID of the model to use. See the L<model endpoint compatibility|/docs/models/model-endpoint-compatibility> table for details on which models work with the Chat API.

=item C<< n >>

How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep C<n> as C<1> to minimize costs.

=item C<< presence_penalty >>

Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.

L<See more information about frequency and presence penalties.|/docs/guides/text-generation/parameter-details>

=item C<< response_format >>

An object specifying the format that the model must output. Compatible with L<GPT-4 Turbo|/docs/models/gpt-4-and-gpt-4-turbo> and all GPT-3.5 Turbo models newer than C<gpt-3.5-turbo-1106>.

Setting to C<{ "type": "json_object" }> enables JSON mode, which guarantees the message the model generates is valid JSON.

B<Important:> when using JSON mode, you B<must> also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if C<finish_reason="length">, which indicates the generation exceeded C<max_tokens> or the conversation exceeded the max context length.

=item C<< seed >>

This feature is in Beta.
If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same C<seed> and parameters should return the same result.
Determinism is not guaranteed, and you should refer to the C<system_fingerprint> response parameter to monitor changes in the backend.

=item C<< stop >>

Up to 4 sequences where the API will stop generating further tokens.

=item C<< stream >>

If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only L<server-sent events|https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format> as they become available, with the stream terminated by a C<data: [DONE]> message. L<Example Python code|https://cookbook.openai.com/examples/how_to_stream_completions>.

=item C<< stream_options >>

Options for streaming response. Only set this when you set C<stream: true>.

=item C<< temperature >>

What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.

We generally recommend altering this or C<top_p> but not both.

=item C<< tool_choice >>

Controls which (if any) tool is called by the model.
C<none> means the model will not call any tool and instead generates a message.
C<auto> means the model can pick between generating a message or calling one or more tools.
C<required> means the model must call one or more tools.
Specifying a particular tool via C<{"type": "function", "function": {"name": "my_function"}}> forces the model to call that tool.

C<none> is the default when no tools are present. C<auto> is the default if tools are present.

=item C<< tools >>

A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.

=item C<< top_logprobs >>

An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. C<logprobs> must be set to C<true> if this parameter is used.

=item C<< top_p >>

An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.

We generally recommend altering this or C<temperature> but not both.

=item C<< user >>

A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. L<Learn more|/docs/guides/safety-best-practices/end-user-ids>.

=back

Returns a L<< AI::OpenAI::CreateChatCompletionResponse >> on success.

=cut

sub _build_createChatCompletion_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/chat/completions';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateChatCompletionRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createChatCompletion( $self, %options ) {
    my $tx = $self->_build_createChatCompletion_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::CreateChatCompletionResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createCompletion >>

  my $res = $client->createCompletion()->get;

Creates a completion for the provided prompt and parameters.


=head3 Options

=over 4

=item C<< best_of >>

Generates C<best_of> completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.

When used with C<n>, C<best_of> controls the number of candidate completions and C<n> specifies how many to return – C<best_of> must be greater than C<n>.

B<Note:> Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for C<max_tokens> and C<stop>.

=item C<< echo >>

Echo back the prompt in addition to the completion

=item C<< frequency_penalty >>

Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.

L<See more information about frequency and presence penalties.|/docs/guides/text-generation/parameter-details>

=item C<< logit_bias >>

Modify the likelihood of specified tokens appearing in the completion.

Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this L<tokenizer tool|/tokenizer?view=bpe> to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.

As an example, you can pass C<{"50256": -100}> to prevent the  token from being generated.

=item C<< logprobs >>

Include the log probabilities on the C<logprobs> most likely output tokens, as well the chosen tokens. For example, if C<logprobs> is 5, the API will return a list of the 5 most likely tokens. The API will always return the C<logprob> of the sampled token, so there may be up to C<logprobs+1> elements in the response.

The maximum value for C<logprobs> is 5.

=item C<< max_tokens >>

The maximum number of L<tokens|/tokenizer> that can be generated in the completion.

The token count of your prompt plus C<max_tokens> cannot exceed the model's context length. L<Example Python code|https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken> for counting tokens.

=item C<< model >>

ID of the model to use. You can use the L<List models|/docs/api-reference/models/list> API to see all of your available models, or see our L<Model overview|/docs/models/overview> for descriptions of them.

=item C<< n >>

How many completions to generate for each prompt.

B<Note:> Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for C<max_tokens> and C<stop>.

=item C<< presence_penalty >>

Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.

L<See more information about frequency and presence penalties.|/docs/guides/text-generation/parameter-details>

=item C<< prompt >>

The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.

Note that  is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.

=item C<< seed >>

If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same C<seed> and parameters should return the same result.

Determinism is not guaranteed, and you should refer to the C<system_fingerprint> response parameter to monitor changes in the backend.

=item C<< stop >>

Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.

=item C<< stream >>

Whether to stream back partial progress. If set, tokens will be sent as data-only L<server-sent events|https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format> as they become available, with the stream terminated by a C<data: [DONE]> message. L<Example Python code|https://cookbook.openai.com/examples/how_to_stream_completions>.

=item C<< stream_options >>

Options for streaming response. Only set this when you set C<stream: true>.

=item C<< suffix >>

The suffix that comes after a completion of inserted text.

This parameter is only supported for C<gpt-3.5-turbo-instruct>.

=item C<< temperature >>

What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.

We generally recommend altering this or C<top_p> but not both.

=item C<< top_p >>

An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.

We generally recommend altering this or C<temperature> but not both.

=item C<< user >>

A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. L<Learn more|/docs/guides/safety-best-practices/end-user-ids>.

=back

Returns a L<< AI::OpenAI::CreateCompletionResponse >> on success.

=cut

sub _build_createCompletion_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/completions';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateCompletionRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createCompletion( $self, %options ) {
    my $tx = $self->_build_createCompletion_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::CreateCompletionResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createEmbedding >>

  my $res = $client->createEmbedding()->get;

Creates an embedding vector representing the input text.


=head3 Options

=over 4

=item C<< dimensions >>

The number of dimensions the resulting output embeddings should have. Only supported in C<text-embedding-3> and later models.

=item C<< encoding_format >>

The format to return the embeddings in. Can be either C<float> or L<C<base64>|https://pypi.org/project/pybase64/>.

=item C<< input >>

Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for C<text-embedding-ada-002>), cannot be an empty string, and any array must be 2048 dimensions or less. L<Example Python code|https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken> for counting tokens.

=item C<< model >>

ID of the model to use. You can use the L<List models|/docs/api-reference/models/list> API to see all of your available models, or see our L<Model overview|/docs/models/overview> for descriptions of them.

=item C<< user >>

A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. L<Learn more|/docs/guides/safety-best-practices/end-user-ids>.

=back

Returns a L<< AI::OpenAI::CreateEmbeddingResponse >> on success.

=cut

sub _build_createEmbedding_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/embeddings';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateEmbeddingRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createEmbedding( $self, %options ) {
    my $tx = $self->_build_createEmbedding_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::CreateEmbeddingResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listFiles >>

  my $res = $client->listFiles()->get;

Returns a list of files that belong to the user's organization.

=head3 Parameters

=over 4

=item B<< purpose >>

Only return files with the given purpose.

=back


Returns a L<< AI::OpenAI::ListFilesResponse >> on success.

=cut

sub _build_listFiles_request( $self, %options ) {
    my $method = 'GET';
    my $path = '/files';
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'purpose' => delete $options{'purpose'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listFiles( $self, %options ) {
    my $tx = $self->_build_listFiles_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListFilesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createFile >>

  my $res = $client->createFile()->get;

Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.

The Assistants API supports files up to 2 million tokens and of specific file types. See the L<Assistants Tools guide|/docs/assistants/tools> for details.

The Fine-tuning API only supports C<.jsonl> files.

The Batch API only supports C<.jsonl> files up to 100 MB in size.

Please L<contact us|https://help.openai.com/> if you need to increase these storage limits.


=head3 Options

=over 4

=item C<< file >>

The File object (not file name) to be uploaded.

=item C<< purpose >>

The intended purpose of the uploaded file.

Use "assistants" for L<Assistants|/docs/api-reference/assistants> and L<Message|/docs/api-reference/messages> files, "vision" for Assistants image file inputs, "batch" for L<Batch API|/docs/guides/batch>, and "fine-tune" for L<Fine-tuning|/docs/api-reference/fine-tuning>.

=back

Returns a L<< AI::OpenAI::OpenAIFile >> on success.

=cut

sub _build_createFile_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/files';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateFileRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'multipart/form-data',
        }
        => form => $request->as_hash,
    );

    return $tx
}


sub createFile( $self, %options ) {
    my $tx = $self->_build_createFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::OpenAIFile->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteFile >>

  my $res = $client->deleteFile()->get;

Delete a file.

=head3 Parameters

=over 4

=item B<< file_id >>

The ID of the file to use for this request.

=back


Returns a L<< AI::OpenAI::DeleteFileResponse >> on success.

=cut

sub _build_deleteFile_request( $self, %options ) {
    croak "Missing required parameter 'file_id'"
        unless exists $options{ 'file_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/files/{file_id}' );
    my $path = $template->process(
              'file_id' => delete $options{'file_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteFile( $self, %options ) {
    my $tx = $self->_build_deleteFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteFileResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< retrieveFile >>

  my $res = $client->retrieveFile()->get;

Returns information about a specific file.

=head3 Parameters

=over 4

=item B<< file_id >>

The ID of the file to use for this request.

=back


Returns a L<< AI::OpenAI::OpenAIFile >> on success.

=cut

sub _build_retrieveFile_request( $self, %options ) {
    croak "Missing required parameter 'file_id'"
        unless exists $options{ 'file_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/files/{file_id}' );
    my $path = $template->process(
              'file_id' => delete $options{'file_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub retrieveFile( $self, %options ) {
    my $tx = $self->_build_retrieveFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::OpenAIFile->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< downloadFile >>

  my $res = $client->downloadFile()->get;

Returns the contents of the specified file.

=head3 Parameters

=over 4

=item B<< file_id >>

The ID of the file to use for this request.

=back


Returns a L<< string >> on success.

=cut

sub _build_downloadFile_request( $self, %options ) {
    croak "Missing required parameter 'file_id'"
        unless exists $options{ 'file_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/files/{file_id}/content' );
    my $path = $template->process(
              'file_id' => delete $options{'file_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub downloadFile( $self, %options ) {
    my $tx = $self->_build_downloadFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    $payload

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listPaginatedFineTuningJobs >>

  my $res = $client->listPaginatedFineTuningJobs()->get;

List your organization's fine-tuning jobs

=head3 Parameters

=over 4

=item B<< after >>

Identifier for the last job from the previous pagination request.

=item B<< limit >>

Number of fine-tuning jobs to retrieve.

=back


Returns a L<< AI::OpenAI::ListPaginatedFineTuningJobsResponse >> on success.

=cut

sub _build_listPaginatedFineTuningJobs_request( $self, %options ) {
    my $method = 'GET';
    my $path = '/fine_tuning/jobs';
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'after' => delete $options{'after'},
        maybe 'limit' => delete $options{'limit'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listPaginatedFineTuningJobs( $self, %options ) {
    my $tx = $self->_build_listPaginatedFineTuningJobs_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListPaginatedFineTuningJobsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createFineTuningJob >>

  my $res = $client->createFineTuningJob()->get;

Creates a fine-tuning job which begins the process of creating a new model from a given dataset.

Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.

L<Learn more about fine-tuning|/docs/guides/fine-tuning>


=head3 Options

=over 4

=item C<< hyperparameters >>

The hyperparameters used for the fine-tuning job.

=item C<< integrations >>

A list of integrations to enable for your fine-tuning job.

=item C<< model >>

The name of the model to fine-tune. You can select one of the
L<supported models|/docs/guides/fine-tuning/what-models-can-be-fine-tuned>.

=item C<< seed >>

The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
If a seed is not specified, one will be generated for you.

=item C<< suffix >>

A string of up to 18 characters that will be added to your fine-tuned model name.

For example, a C<suffix> of "custom-model-name" would produce a model name like C<ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel>.

=item C<< training_file >>

The ID of an uploaded file that contains training data.

See L<upload file|/docs/api-reference/files/create> for how to upload a file.

Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose C<fine-tune>.

See the L<fine-tuning guide|/docs/guides/fine-tuning> for more details.

=item C<< validation_file >>

The ID of an uploaded file that contains validation data.

If you provide this file, the data is used to generate validation
metrics periodically during fine-tuning. These metrics can be viewed in
the fine-tuning results file.
The same data should not be present in both train and validation files.

Your dataset must be formatted as a JSONL file. You must upload your file with the purpose C<fine-tune>.

See the L<fine-tuning guide|/docs/guides/fine-tuning> for more details.

=back

Returns a L<< AI::OpenAI::FineTuningJob >> on success.

=cut

sub _build_createFineTuningJob_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/fine_tuning/jobs';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateFineTuningJobRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createFineTuningJob( $self, %options ) {
    my $tx = $self->_build_createFineTuningJob_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::FineTuningJob->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< retrieveFineTuningJob >>

  my $res = $client->retrieveFineTuningJob()->get;

Get info about a fine-tuning job.

L<Learn more about fine-tuning|/docs/guides/fine-tuning>

=head3 Parameters

=over 4

=item B<< fine_tuning_job_id >>

The ID of the fine-tuning job.

=back


Returns a L<< AI::OpenAI::FineTuningJob >> on success.

=cut

sub _build_retrieveFineTuningJob_request( $self, %options ) {
    croak "Missing required parameter 'fine_tuning_job_id'"
        unless exists $options{ 'fine_tuning_job_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/fine_tuning/jobs/{fine_tuning_job_id}' );
    my $path = $template->process(
              'fine_tuning_job_id' => delete $options{'fine_tuning_job_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub retrieveFineTuningJob( $self, %options ) {
    my $tx = $self->_build_retrieveFineTuningJob_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::FineTuningJob->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< cancelFineTuningJob >>

  my $res = $client->cancelFineTuningJob()->get;

Immediately cancel a fine-tune job.

=head3 Parameters

=over 4

=item B<< fine_tuning_job_id >>

The ID of the fine-tuning job to cancel.

=back


Returns a L<< AI::OpenAI::FineTuningJob >> on success.

=cut

sub _build_cancelFineTuningJob_request( $self, %options ) {
    croak "Missing required parameter 'fine_tuning_job_id'"
        unless exists $options{ 'fine_tuning_job_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/fine_tuning/jobs/{fine_tuning_job_id}/cancel' );
    my $path = $template->process(
              'fine_tuning_job_id' => delete $options{'fine_tuning_job_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub cancelFineTuningJob( $self, %options ) {
    my $tx = $self->_build_cancelFineTuningJob_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::FineTuningJob->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listFineTuningJobCheckpoints >>

  my $res = $client->listFineTuningJobCheckpoints()->get;

List checkpoints for a fine-tuning job.

=head3 Parameters

=over 4

=item B<< fine_tuning_job_id >>

The ID of the fine-tuning job to get checkpoints for.

=item B<< after >>

Identifier for the last checkpoint ID from the previous pagination request.

=item B<< limit >>

Number of checkpoints to retrieve.

=back


Returns a L<< AI::OpenAI::ListFineTuningJobCheckpointsResponse >> on success.

=cut

sub _build_listFineTuningJobCheckpoints_request( $self, %options ) {
    croak "Missing required parameter 'fine_tuning_job_id'"
        unless exists $options{ 'fine_tuning_job_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/fine_tuning/jobs/{fine_tuning_job_id}/checkpoints' );
    my $path = $template->process(
              'fine_tuning_job_id' => delete $options{'fine_tuning_job_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'after' => delete $options{'after'},
        maybe 'limit' => delete $options{'limit'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listFineTuningJobCheckpoints( $self, %options ) {
    my $tx = $self->_build_listFineTuningJobCheckpoints_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListFineTuningJobCheckpointsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listFineTuningEvents >>

  my $res = $client->listFineTuningEvents()->get;

Get status updates for a fine-tuning job.

=head3 Parameters

=over 4

=item B<< fine_tuning_job_id >>

The ID of the fine-tuning job to get events for.

=item B<< after >>

Identifier for the last event from the previous pagination request.

=item B<< limit >>

Number of events to retrieve.

=back


Returns a L<< AI::OpenAI::ListFineTuningJobEventsResponse >> on success.

=cut

sub _build_listFineTuningEvents_request( $self, %options ) {
    croak "Missing required parameter 'fine_tuning_job_id'"
        unless exists $options{ 'fine_tuning_job_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/fine_tuning/jobs/{fine_tuning_job_id}/events' );
    my $path = $template->process(
              'fine_tuning_job_id' => delete $options{'fine_tuning_job_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'after' => delete $options{'after'},
        maybe 'limit' => delete $options{'limit'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listFineTuningEvents( $self, %options ) {
    my $tx = $self->_build_listFineTuningEvents_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListFineTuningJobEventsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createImageEdit >>

  my $res = $client->createImageEdit()->get;

Creates an edited or extended image given an original image and a prompt.


=head3 Options

=over 4

=item C<< image >>

The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.

=item C<< mask >>

An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where C<image> should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as C<image>.

=item C<< model >>

The model to use for image generation. Only C<dall-e-2> is supported at this time.

=item C<< n >>

The number of images to generate. Must be between 1 and 10.

=item C<< prompt >>

A text description of the desired image(s). The maximum length is 1000 characters.

=item C<< response_format >>

The format in which the generated images are returned. Must be one of C<url> or C<b64_json>. URLs are only valid for 60 minutes after the image has been generated.

=item C<< size >>

The size of the generated images. Must be one of C<256x256>, C<512x512>, or C<1024x1024>.

=item C<< user >>

A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. L<Learn more|/docs/guides/safety-best-practices/end-user-ids>.

=back

Returns a L<< AI::OpenAI::ImagesResponse >> on success.

=cut

sub _build_createImageEdit_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/images/edits';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateImageEditRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'multipart/form-data',
        }
        => form => $request->as_hash,
    );

    return $tx
}


sub createImageEdit( $self, %options ) {
    my $tx = $self->_build_createImageEdit_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ImagesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createImage >>

  my $res = $client->createImage()->get;

Creates an image given a prompt.


=head3 Options

=over 4

=item C<< model >>

The model to use for image generation.

=item C<< n >>

The number of images to generate. Must be between 1 and 10. For C<dall-e-3>, only C<n=1> is supported.

=item C<< prompt >>

A text description of the desired image(s). The maximum length is 1000 characters for C<dall-e-2> and 4000 characters for C<dall-e-3>.

=item C<< quality >>

The quality of the image that will be generated. C<hd> creates images with finer details and greater consistency across the image. This param is only supported for C<dall-e-3>.

=item C<< response_format >>

The format in which the generated images are returned. Must be one of C<url> or C<b64_json>. URLs are only valid for 60 minutes after the image has been generated.

=item C<< size >>

The size of the generated images. Must be one of C<256x256>, C<512x512>, or C<1024x1024> for C<dall-e-2>. Must be one of C<1024x1024>, C<1792x1024>, or C<1024x1792> for C<dall-e-3> models.

=item C<< style >>

The style of the generated images. Must be one of C<vivid> or C<natural>. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for C<dall-e-3>.

=item C<< user >>

A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. L<Learn more|/docs/guides/safety-best-practices/end-user-ids>.

=back

Returns a L<< AI::OpenAI::ImagesResponse >> on success.

=cut

sub _build_createImage_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/images/generations';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateImageRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createImage( $self, %options ) {
    my $tx = $self->_build_createImage_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ImagesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createImageVariation >>

  my $res = $client->createImageVariation()->get;

Creates a variation of a given image.


=head3 Options

=over 4

=item C<< image >>

The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.

=item C<< model >>

The model to use for image generation. Only C<dall-e-2> is supported at this time.

=item C<< n >>

The number of images to generate. Must be between 1 and 10. For C<dall-e-3>, only C<n=1> is supported.

=item C<< response_format >>

The format in which the generated images are returned. Must be one of C<url> or C<b64_json>. URLs are only valid for 60 minutes after the image has been generated.

=item C<< size >>

The size of the generated images. Must be one of C<256x256>, C<512x512>, or C<1024x1024>.

=item C<< user >>

A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. L<Learn more|/docs/guides/safety-best-practices/end-user-ids>.

=back

Returns a L<< AI::OpenAI::ImagesResponse >> on success.

=cut

sub _build_createImageVariation_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/images/variations';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateImageVariationRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'multipart/form-data',
        }
        => form => $request->as_hash,
    );

    return $tx
}


sub createImageVariation( $self, %options ) {
    my $tx = $self->_build_createImageVariation_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ImagesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listModels >>

  my $res = $client->listModels()->get;

Lists the currently available models, and provides basic information about each one such as the owner and availability.


Returns a L<< AI::OpenAI::ListModelsResponse >> on success.

=cut

sub _build_listModels_request( $self, %options ) {
    my $method = 'GET';
    my $path = '/models';
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listModels( $self, %options ) {
    my $tx = $self->_build_listModels_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListModelsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteModel >>

  my $res = $client->deleteModel()->get;

Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.

=head3 Parameters

=over 4

=item B<< model >>

The model to delete

=back


Returns a L<< AI::OpenAI::DeleteModelResponse >> on success.

=cut

sub _build_deleteModel_request( $self, %options ) {
    croak "Missing required parameter 'model'"
        unless exists $options{ 'model' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/models/{model}' );
    my $path = $template->process(
              'model' => delete $options{'model'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteModel( $self, %options ) {
    my $tx = $self->_build_deleteModel_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteModelResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< retrieveModel >>

  my $res = $client->retrieveModel()->get;

Retrieves a model instance, providing basic information about the model such as the owner and permissioning.

=head3 Parameters

=over 4

=item B<< model >>

The ID of the model to use for this request

=back


Returns a L<< AI::OpenAI::Model >> on success.

=cut

sub _build_retrieveModel_request( $self, %options ) {
    croak "Missing required parameter 'model'"
        unless exists $options{ 'model' };

    my $method = 'GET';
    my $template = URI::Template->new( '/models/{model}' );
    my $path = $template->process(
              'model' => delete $options{'model'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub retrieveModel( $self, %options ) {
    my $tx = $self->_build_retrieveModel_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::Model->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createModeration >>

  my $res = $client->createModeration()->get;

Classifies if text is potentially harmful.


=head3 Options

=over 4

=item C<< input >>

The input text to classify

=item C<< model >>

Two content moderations models are available: C<text-moderation-stable> and C<text-moderation-latest>.

The default is C<text-moderation-latest> which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use C<text-moderation-stable>, we will provide advanced notice before updating the model. Accuracy of C<text-moderation-stable> may be slightly lower than for C<text-moderation-latest>.

=back

Returns a L<< AI::OpenAI::CreateModerationResponse >> on success.

=cut

sub _build_createModeration_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/moderations';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateModerationRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createModeration( $self, %options ) {
    my $tx = $self->_build_createModeration_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::CreateModerationResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createThread >>

  my $res = $client->createThread()->get;

Create a thread.


=head3 Options

=over 4

=item C<< messages >>

A list of L<messages|/docs/api-reference/messages> to start the thread with.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< tool_resources >>

A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the C<code_interpreter> tool requires a list of file IDs, while the C<file_search> tool requires a list of vector store IDs.

=back

Returns a L<< AI::OpenAI::ThreadObject >> on success.

=cut

sub _build_createThread_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/threads';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateThreadRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createThread( $self, %options ) {
    my $tx = $self->_build_createThread_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ThreadObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createThreadAndRun >>

  my $res = $client->createThreadAndRun()->get;

Create a thread and run it in one request.


=head3 Options

=over 4

=item C<< assistant_id >>

The ID of the L<assistant|/docs/api-reference/assistants> to use to execute this run.

=item C<< instructions >>

Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.

=item C<< max_completion_tokens >>

The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status C<incomplete>. See C<incomplete_details> for more info.

=item C<< max_prompt_tokens >>

The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status C<incomplete>. See C<incomplete_details> for more info.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< model >>

The ID of the L<Model|/docs/api-reference/models> to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.

=item C<< response_format >>

Specifies the format that the model must output. Compatible with L<GPT-4o|/docs/models/gpt-4o>, L<GPT-4 Turbo|/docs/models/gpt-4-turbo-and-gpt-4>, and all GPT-3.5 Turbo models since C<gpt-3.5-turbo-1106>.

Setting to C<{ "type": "json_object" }> enables JSON mode, which guarantees the message the model generates is valid JSON.

B<Important:> when using JSON mode, you B<must> also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if C<finish_reason="length">, which indicates the generation exceeded C<max_tokens> or the conversation exceeded the max context length.

=item C<< stream >>

If C<true>, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a C<data: [DONE]> message.

=item C<< temperature >>

What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.

=item C<< thread >>

=item C<< tool_choice >>

Controls which (if any) tool is called by the model.
C<none> means the model will not call any tools and instead generates a message.
C<auto> is the default value and means the model can pick between generating a message or calling one or more tools.
C<required> means the model must call one or more tools before responding to the user.
Specifying a particular tool like C<{"type": "file_search"}> or C<{"type": "function", "function": {"name": "my_function"}}> forces the model to call that tool.

=item C<< tool_resources >>

A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the C<code_interpreter> tool requires a list of file IDs, while the C<file_search> tool requires a list of vector store IDs.

=item C<< tools >>

Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.

=item C<< top_p >>

An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.

We generally recommend altering this or temperature but not both.

=item C<< truncation_strategy >>

Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.

=back

Returns a L<< AI::OpenAI::RunObject >> on success.

=cut

sub _build_createThreadAndRun_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/threads/runs';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateThreadAndRunRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createThreadAndRun( $self, %options ) {
    my $tx = $self->_build_createThreadAndRun_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteThread >>

  my $res = $client->deleteThread()->get;

Delete a thread.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to delete.

=back


Returns a L<< AI::OpenAI::DeleteThreadResponse >> on success.

=cut

sub _build_deleteThread_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/threads/{thread_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteThread( $self, %options ) {
    my $tx = $self->_build_deleteThread_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteThreadResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getThread >>

  my $res = $client->getThread()->get;

Retrieves a thread.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to retrieve.

=back


Returns a L<< AI::OpenAI::ThreadObject >> on success.

=cut

sub _build_getThread_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getThread( $self, %options ) {
    my $tx = $self->_build_getThread_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ThreadObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< modifyThread >>

  my $res = $client->modifyThread()->get;

Modifies a thread.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to modify. Only the C<metadata> can be modified.

=back


=head3 Options

=over 4

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< tool_resources >>

A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the C<code_interpreter> tool requires a list of file IDs, while the C<file_search> tool requires a list of vector store IDs.

=back

Returns a L<< AI::OpenAI::ThreadObject >> on success.

=cut

sub _build_modifyThread_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::ModifyThreadRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub modifyThread( $self, %options ) {
    my $tx = $self->_build_modifyThread_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ThreadObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listMessages >>

  my $res = $client->listMessages()->get;

Returns a list of messages for a given thread.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the L<thread|/docs/api-reference/threads> the messages belong to.

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=item B<< run_id >>

Filter messages by the run ID that generated them.

=back


Returns a L<< AI::OpenAI::ListMessagesResponse >> on success.

=cut

sub _build_listMessages_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}/messages' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
        maybe 'run_id' => delete $options{'run_id'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listMessages( $self, %options ) {
    my $tx = $self->_build_listMessages_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListMessagesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createMessage >>

  my $res = $client->createMessage()->get;

Create a message.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the L<thread|/docs/api-reference/threads> to create a message for.

=back


=head3 Options

=over 4

=item C<< attachments >>

A list of files attached to the message, and the tools they should be added to.

=item C<< content >>

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< role >>

The role of the entity that is creating the message. Allowed values include:
- C<user>: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.
- C<assistant>: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.

=back

Returns a L<< AI::OpenAI::MessageObject >> on success.

=cut

sub _build_createMessage_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}/messages' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateMessageRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createMessage( $self, %options ) {
    my $tx = $self->_build_createMessage_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::MessageObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteMessage >>

  my $res = $client->deleteMessage()->get;

Deletes a message.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to which this message belongs.

=item B<< message_id >>

The ID of the message to delete.

=back


Returns a L<< AI::OpenAI::DeleteMessageResponse >> on success.

=cut

sub _build_deleteMessage_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'message_id'"
        unless exists $options{ 'message_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/threads/{thread_id}/messages/{message_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'message_id' => delete $options{'message_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteMessage( $self, %options ) {
    my $tx = $self->_build_deleteMessage_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteMessageResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getMessage >>

  my $res = $client->getMessage()->get;

Retrieve a message.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the L<thread|/docs/api-reference/threads> to which this message belongs.

=item B<< message_id >>

The ID of the message to retrieve.

=back


Returns a L<< AI::OpenAI::MessageObject >> on success.

=cut

sub _build_getMessage_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'message_id'"
        unless exists $options{ 'message_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}/messages/{message_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'message_id' => delete $options{'message_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getMessage( $self, %options ) {
    my $tx = $self->_build_getMessage_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::MessageObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< modifyMessage >>

  my $res = $client->modifyMessage()->get;

Modifies a message.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to which this message belongs.

=item B<< message_id >>

The ID of the message to modify.

=back


=head3 Options

=over 4

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=back

Returns a L<< AI::OpenAI::MessageObject >> on success.

=cut

sub _build_modifyMessage_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'message_id'"
        unless exists $options{ 'message_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}/messages/{message_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'message_id' => delete $options{'message_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::ModifyMessageRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub modifyMessage( $self, %options ) {
    my $tx = $self->_build_modifyMessage_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::MessageObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listRuns >>

  my $res = $client->listRuns()->get;

Returns a list of runs belonging to a thread.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread the run belongs to.

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=back


Returns a L<< AI::OpenAI::ListRunsResponse >> on success.

=cut

sub _build_listRuns_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}/runs' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listRuns( $self, %options ) {
    my $tx = $self->_build_listRuns_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListRunsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createRun >>

  my $res = $client->createRun()->get;

Create a run.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to run.

=back


=head3 Options

=over 4

=item C<< additional_instructions >>

Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.

=item C<< additional_messages >>

Adds additional messages to the thread before creating the run.

=item C<< assistant_id >>

The ID of the L<assistant|/docs/api-reference/assistants> to use to execute this run.

=item C<< instructions >>

Overrides the L<instructions|/docs/api-reference/assistants/createAssistant> of the assistant. This is useful for modifying the behavior on a per-run basis.

=item C<< max_completion_tokens >>

The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status C<incomplete>. See C<incomplete_details> for more info.

=item C<< max_prompt_tokens >>

The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status C<incomplete>. See C<incomplete_details> for more info.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< model >>

The ID of the L<Model|/docs/api-reference/models> to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.

=item C<< response_format >>

Specifies the format that the model must output. Compatible with L<GPT-4o|/docs/models/gpt-4o>, L<GPT-4 Turbo|/docs/models/gpt-4-turbo-and-gpt-4>, and all GPT-3.5 Turbo models since C<gpt-3.5-turbo-1106>.

Setting to C<{ "type": "json_object" }> enables JSON mode, which guarantees the message the model generates is valid JSON.

B<Important:> when using JSON mode, you B<must> also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if C<finish_reason="length">, which indicates the generation exceeded C<max_tokens> or the conversation exceeded the max context length.

=item C<< stream >>

If C<true>, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a C<data: [DONE]> message.

=item C<< temperature >>

What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.

=item C<< tool_choice >>

Controls which (if any) tool is called by the model.
C<none> means the model will not call any tools and instead generates a message.
C<auto> is the default value and means the model can pick between generating a message or calling one or more tools.
C<required> means the model must call one or more tools before responding to the user.
Specifying a particular tool like C<{"type": "file_search"}> or C<{"type": "function", "function": {"name": "my_function"}}> forces the model to call that tool.

=item C<< tools >>

Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.

=item C<< top_p >>

An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.

We generally recommend altering this or temperature but not both.

=item C<< truncation_strategy >>

Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.

=back

Returns a L<< AI::OpenAI::RunObject >> on success.

=cut

sub _build_createRun_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}/runs' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateRunRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createRun( $self, %options ) {
    my $tx = $self->_build_createRun_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getRun >>

  my $res = $client->getRun()->get;

Retrieves a run.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the L<thread|/docs/api-reference/threads> that was run.

=item B<< run_id >>

The ID of the run to retrieve.

=back


Returns a L<< AI::OpenAI::RunObject >> on success.

=cut

sub _build_getRun_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'run_id'"
        unless exists $options{ 'run_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}/runs/{run_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'run_id' => delete $options{'run_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getRun( $self, %options ) {
    my $tx = $self->_build_getRun_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< modifyRun >>

  my $res = $client->modifyRun()->get;

Modifies a run.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the L<thread|/docs/api-reference/threads> that was run.

=item B<< run_id >>

The ID of the run to modify.

=back


=head3 Options

=over 4

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=back

Returns a L<< AI::OpenAI::RunObject >> on success.

=cut

sub _build_modifyRun_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'run_id'"
        unless exists $options{ 'run_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}/runs/{run_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'run_id' => delete $options{'run_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::ModifyRunRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub modifyRun( $self, %options ) {
    my $tx = $self->_build_modifyRun_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< cancelRun >>

  my $res = $client->cancelRun()->get;

Cancels a run that is C<in_progress>.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to which this run belongs.

=item B<< run_id >>

The ID of the run to cancel.

=back


Returns a L<< AI::OpenAI::RunObject >> on success.

=cut

sub _build_cancelRun_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'run_id'"
        unless exists $options{ 'run_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}/runs/{run_id}/cancel' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'run_id' => delete $options{'run_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub cancelRun( $self, %options ) {
    my $tx = $self->_build_cancelRun_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listRunSteps >>

  my $res = $client->listRunSteps()->get;

Returns a list of run steps belonging to a run.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread the run and run steps belong to.

=item B<< run_id >>

The ID of the run the run steps belong to.

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=back


Returns a L<< AI::OpenAI::ListRunStepsResponse >> on success.

=cut

sub _build_listRunSteps_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'run_id'"
        unless exists $options{ 'run_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}/runs/{run_id}/steps' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'run_id' => delete $options{'run_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listRunSteps( $self, %options ) {
    my $tx = $self->_build_listRunSteps_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListRunStepsResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getRunStep >>

  my $res = $client->getRunStep()->get;

Retrieves a run step.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the thread to which the run and run step belongs.

=item B<< run_id >>

The ID of the run to which the run step belongs.

=item B<< step_id >>

The ID of the run step to retrieve.

=back


Returns a L<< AI::OpenAI::RunStepObject >> on success.

=cut

sub _build_getRunStep_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'run_id'"
        unless exists $options{ 'run_id' };
    croak "Missing required parameter 'step_id'"
        unless exists $options{ 'step_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/threads/{thread_id}/runs/{run_id}/steps/{step_id}' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'run_id' => delete $options{'run_id'},
              'step_id' => delete $options{'step_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getRunStep( $self, %options ) {
    my $tx = $self->_build_getRunStep_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunStepObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< submitToolOuputsToRun >>

  my $res = $client->submitToolOuputsToRun()->get;

When a run has the C<status: "requires_action"> and C<required_action.type> is C<submit_tool_outputs>, this endpoint can be used to submit the outputs from the tool calls once they're all completed. All outputs must be submitted in a single request.

=head3 Parameters

=over 4

=item B<< thread_id >>

The ID of the L<thread|/docs/api-reference/threads> to which this run belongs.

=item B<< run_id >>

The ID of the run that requires the tool output submission.

=back


=head3 Options

=over 4

=item C<< stream >>

If C<true>, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a C<data: [DONE]> message.

=item C<< tool_outputs >>

A list of tools for which the outputs are being submitted.

=back

Returns a L<< AI::OpenAI::RunObject >> on success.

=cut

sub _build_submitToolOuputsToRun_request( $self, %options ) {
    croak "Missing required parameter 'thread_id'"
        unless exists $options{ 'thread_id' };
    croak "Missing required parameter 'run_id'"
        unless exists $options{ 'run_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/threads/{thread_id}/runs/{run_id}/submit_tool_outputs' );
    my $path = $template->process(
              'thread_id' => delete $options{'thread_id'},
              'run_id' => delete $options{'run_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::SubmitToolOutputsRunRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub submitToolOuputsToRun( $self, %options ) {
    my $tx = $self->_build_submitToolOuputsToRun_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::RunObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listVectorStores >>

  my $res = $client->listVectorStores()->get;

Returns a list of vector stores.

=head3 Parameters

=over 4

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=back


Returns a L<< AI::OpenAI::ListVectorStoresResponse >> on success.

=cut

sub _build_listVectorStores_request( $self, %options ) {
    my $method = 'GET';
    my $path = '/vector_stores';
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listVectorStores( $self, %options ) {
    my $tx = $self->_build_listVectorStores_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListVectorStoresResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createVectorStore >>

  my $res = $client->createVectorStore()->get;

Create a vector store.


=head3 Options

=over 4

=item C<< expires_after >>

The expiration policy for a vector store.

=item C<< file_ids >>

A list of L<File|/docs/api-reference/files> IDs that the vector store should use. Useful for tools like C<file_search> that can access files.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< name >>

The name of the vector store.

=back

Returns a L<< AI::OpenAI::VectorStoreObject >> on success.

=cut

sub _build_createVectorStore_request( $self, %options ) {
    my $method = 'POST';
    my $path = '/vector_stores';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateVectorStoreRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createVectorStore( $self, %options ) {
    my $tx = $self->_build_createVectorStore_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteVectorStore >>

  my $res = $client->deleteVectorStore()->get;

Delete a vector store.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store to delete.

=back


Returns a L<< AI::OpenAI::DeleteVectorStoreResponse >> on success.

=cut

sub _build_deleteVectorStore_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteVectorStore( $self, %options ) {
    my $tx = $self->_build_deleteVectorStore_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteVectorStoreResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getVectorStore >>

  my $res = $client->getVectorStore()->get;

Retrieves a vector store.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store to retrieve.

=back


Returns a L<< AI::OpenAI::VectorStoreObject >> on success.

=cut

sub _build_getVectorStore_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getVectorStore( $self, %options ) {
    my $tx = $self->_build_getVectorStore_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< modifyVectorStore >>

  my $res = $client->modifyVectorStore()->get;

Modifies a vector store.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store to modify.

=back


=head3 Options

=over 4

=item C<< expires_after >>

The expiration policy for a vector store.

=item C<< metadata >>

Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long.

=item C<< name >>

The name of the vector store.

=back

Returns a L<< AI::OpenAI::VectorStoreObject >> on success.

=cut

sub _build_modifyVectorStore_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::UpdateVectorStoreRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub modifyVectorStore( $self, %options ) {
    my $tx = $self->_build_modifyVectorStore_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createVectorStoreFileBatch >>

  my $res = $client->createVectorStoreFileBatch()->get;

Create a vector store file batch.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store for which to create a File Batch.

=back


=head3 Options

=over 4

=item C<< file_ids >>

A list of L<File|/docs/api-reference/files> IDs that the vector store should use. Useful for tools like C<file_search> that can access files.

=back

Returns a L<< AI::OpenAI::VectorStoreFileBatchObject >> on success.

=cut

sub _build_createVectorStoreFileBatch_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/file_batches' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateVectorStoreFileBatchRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createVectorStoreFileBatch( $self, %options ) {
    my $tx = $self->_build_createVectorStoreFileBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreFileBatchObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getVectorStoreFileBatch >>

  my $res = $client->getVectorStoreFileBatch()->get;

Retrieves a vector store file batch.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store that the file batch belongs to.

=item B<< batch_id >>

The ID of the file batch being retrieved.

=back


Returns a L<< AI::OpenAI::VectorStoreFileBatchObject >> on success.

=cut

sub _build_getVectorStoreFileBatch_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };
    croak "Missing required parameter 'batch_id'"
        unless exists $options{ 'batch_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/file_batches/{batch_id}' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
              'batch_id' => delete $options{'batch_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getVectorStoreFileBatch( $self, %options ) {
    my $tx = $self->_build_getVectorStoreFileBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreFileBatchObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< cancelVectorStoreFileBatch >>

  my $res = $client->cancelVectorStoreFileBatch()->get;

Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store that the file batch belongs to.

=item B<< batch_id >>

The ID of the file batch to cancel.

=back


Returns a L<< AI::OpenAI::VectorStoreFileBatchObject >> on success.

=cut

sub _build_cancelVectorStoreFileBatch_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };
    croak "Missing required parameter 'batch_id'"
        unless exists $options{ 'batch_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
              'batch_id' => delete $options{'batch_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub cancelVectorStoreFileBatch( $self, %options ) {
    my $tx = $self->_build_cancelVectorStoreFileBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreFileBatchObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listFilesInVectorStoreBatch >>

  my $res = $client->listFilesInVectorStoreBatch()->get;

Returns a list of vector store files in a batch.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store that the files belong to.

=item B<< batch_id >>

The ID of the file batch that the files belong to.

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=item B<< filter >>

Filter by file status. One of C<in_progress>, C<completed>, C<failed>, C<cancelled>.

=back


Returns a L<< AI::OpenAI::ListVectorStoreFilesResponse >> on success.

=cut

sub _build_listFilesInVectorStoreBatch_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };
    croak "Missing required parameter 'batch_id'"
        unless exists $options{ 'batch_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/file_batches/{batch_id}/files' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
              'batch_id' => delete $options{'batch_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
        maybe 'filter' => delete $options{'filter'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listFilesInVectorStoreBatch( $self, %options ) {
    my $tx = $self->_build_listFilesInVectorStoreBatch_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListVectorStoreFilesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< listVectorStoreFiles >>

  my $res = $client->listVectorStoreFiles()->get;

Returns a list of vector store files.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store that the files belong to.

=item B<< limit >>

A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.

=item B<< order >>

Sort order by the C<created_at> timestamp of the objects. C<asc> for ascending order and C<desc> for descending order.

=item B<< after >>

A cursor for use in pagination. C<after> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include after=obj>foo in order to fetch the next page of the list.

=item B<< before >>

A cursor for use in pagination. C<before> is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with objI<foo, your subsequent call can include before=obj>foo in order to fetch the previous page of the list.

=item B<< filter >>

Filter by file status. One of C<in_progress>, C<completed>, C<failed>, C<cancelled>.

=back


Returns a L<< AI::OpenAI::ListVectorStoreFilesResponse >> on success.

=cut

sub _build_listVectorStoreFiles_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/files' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'limit' => delete $options{'limit'},
        maybe 'order' => delete $options{'order'},
        maybe 'after' => delete $options{'after'},
        maybe 'before' => delete $options{'before'},
        maybe 'filter' => delete $options{'filter'},
    );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub listVectorStoreFiles( $self, %options ) {
    my $tx = $self->_build_listVectorStoreFiles_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::ListVectorStoreFilesResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< createVectorStoreFile >>

  my $res = $client->createVectorStoreFile()->get;

Create a vector store file by attaching a L<File|/docs/api-reference/files> to a L<vector store|/docs/api-reference/vector-stores/object>.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store for which to create a File.

=back


=head3 Options

=over 4

=item C<< file_id >>

A L<File|/docs/api-reference/files> ID that the vector store should use. Useful for tools like C<file_search> that can access files.

=back

Returns a L<< AI::OpenAI::VectorStoreFileObject >> on success.

=cut

sub _build_createVectorStoreFile_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };

    my $method = 'POST';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/files' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = AI::OpenAI::CreateVectorStoreFileRequest->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    return $tx
}


sub createVectorStoreFile( $self, %options ) {
    my $tx = $self->_build_createVectorStoreFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreFileObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deleteVectorStoreFile >>

  my $res = $client->deleteVectorStoreFile()->get;

Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the L<delete file|/docs/api-reference/files/delete> endpoint.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store that the file belongs to.

=item B<< file_id >>

The ID of the file to delete.

=back


Returns a L<< AI::OpenAI::DeleteVectorStoreFileResponse >> on success.

=cut

sub _build_deleteVectorStoreFile_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };
    croak "Missing required parameter 'file_id'"
        unless exists $options{ 'file_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/files/{file_id}' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
              'file_id' => delete $options{'file_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub deleteVectorStoreFile( $self, %options ) {
    my $tx = $self->_build_deleteVectorStoreFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::DeleteVectorStoreFileResponse->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< getVectorStoreFile >>

  my $res = $client->getVectorStoreFile()->get;

Retrieves a vector store file.

=head3 Parameters

=over 4

=item B<< vector_store_id >>

The ID of the vector store that the file belongs to.

=item B<< file_id >>

The ID of the file being retrieved.

=back


Returns a L<< AI::OpenAI::VectorStoreFileObject >> on success.

=cut

sub _build_getVectorStoreFile_request( $self, %options ) {
    croak "Missing required parameter 'vector_store_id'"
        unless exists $options{ 'vector_store_id' };
    croak "Missing required parameter 'file_id'"
        unless exists $options{ 'file_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/vector_stores/{vector_store_id}/files/{file_id}' );
    my $path = $template->process(
              'vector_store_id' => delete $options{'vector_store_id'},
              'file_id' => delete $options{'file_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
    );

    return $tx
}


sub getVectorStoreFile( $self, %options ) {
    my $tx = $self->_build_getVectorStoreFile_request(%options);

    # validate our request while developing
    if( my $openapi = $self->openapi ) {
        my $results = $openapi->validate_request($tx->req);
        if( $results->{error}) {
            say $results;
            say $tx->req->to_string;
        };
    };


    my $res = Future::Mojo->new();

    my $r1 = Future::Mojo->new();
    $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # OK
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                $res->done(
                    AI::OpenAI::VectorStoreFileObject->new($payload),

                );
            } else {
                # Unknown/unhandled content type
                $res->fail( $resp );
            }
        } else {
            # An unknown/unhandled response, likely an error
            $res->fail($resp);
        }
    })->retain;

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    })->catch(sub($err) {
        $r1->fail( $err => $tx );
        undef $r1;
    });

    return $res
}


1;
