package Speech::Recognition::Whisper::Client::Impl 0.01;
# DO NOT EDIT! This is an autogenerated file.
use 5.020;
use Moo 2;
use experimental 'signatures';
use PerlX::Maybe;
use Carp 'croak';

# These should go into a ::Role
use YAML::PP;
use Mojo::UserAgent;
use Mojo::URL;
use Mojo::JSON 'encode_json', 'decode_json';
use OpenAPI::Modern;

use Future::Mojo;

use Speech::Recognition::Whisper::Body_post_audio_api_v1_transcribe__post;
use Speech::Recognition::Whisper::HTTPValidationError;
use Speech::Recognition::Whisper::PasswordUpdate;
use Speech::Recognition::Whisper::PingResponse;
use Speech::Recognition::Whisper::Response_Token;
use Speech::Recognition::Whisper::Transcription;
use Speech::Recognition::Whisper::User;
use Speech::Recognition::Whisper::UserDeletedResponse;
use Speech::Recognition::Whisper::UserResponse;
use Speech::Recognition::Whisper::User_GET_TOKEN;
use Speech::Recognition::Whisper::ValidationError;

=head1 SYNOPSIS

=head1 PROPERTIES

=head2 B<< openapi >>

=head2 B<< ua >>

=head2 B<< server >>

=cut

# XXX this should be more configurable, and potentially you don't want validation?!
has 'schema' => (
    is => 'lazy',
    default => sub {
        YAML::PP->new( boolean => 'JSON::PP' )->load_file( 'ollama/ollama-curated.yaml' );
    },
);

has 'openapi' => (
    is => 'lazy',
    default => sub { OpenAPI::Modern->new( openapi_schema => $_[0]->schema, openapi_uri => '/api' )},
);

# The HTTP stuff should go into a ::Role I guess
has 'ua' => (
    is => 'lazy',
    default => sub { Mojo::UserAgent->new },
);

has 'server' => (
    is => 'lazy',
    default => sub { 'http://localhost:11434/api' }, # XXX pull from OpenAPI file instead
);

=head1 METHODS

=head2 C<< transcribe >>

  my $res = $client->transcribe()->get;

Post Audio

=head3 Parameters

=over 4

=item B<< model >>

=item B<< Authentication >>

=back


=head3 Options

=over 4

=item C<< file >>

=back

Returns a L<< Speech::Recognition::Whisper::Transcription >>.
Returns a L<< Speech::Recognition::Whisper::HTTPValidationError >>.

=cut

sub transcribe( $self, %options ) {
    my $method = 'POST';
    my $path = '/api/v1/transcribe/';
    my $url = Mojo::URL->new( $self->server . $path );

    $url->query->merge(
        maybe 'model' => delete $options{'model'},
    );

    my $request = Speech::Recognition::Whisper::Body_post_audio_api_v1_transcribe__post->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'multipart/form-data',
             maybe 'Authentication' => delete $options{'Authentication'}
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::Transcription->new($payload),

                );
            }
        } elsif( $resp->code == 422 ) {
            # Validation Error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::HTTPValidationError->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< create_user >>

  my $res = $client->create_user()->get;

Create User


=head3 Options

=over 4

=item C<< email >>

=item C<< password >>

=item C<< username >>

=back

Returns a L<< Speech::Recognition::Whisper::UserResponse >>.
Returns a L<< Speech::Recognition::Whisper::HTTPValidationError >>.

=cut

sub create_user( $self, %options ) {
    my $method = 'POST';
    my $path = '/api/v1/users/';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = Speech::Recognition::Whisper::User->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 201 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::UserResponse->new($payload),

                );
            }
        } elsif( $resp->code == 422 ) {
            # Validation Error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::HTTPValidationError->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< get_user_token >>

  my $res = $client->get_user_token()->get;

Get User Token


=head3 Options

=over 4

=item C<< email >>

=item C<< password >>

=back

Returns a L<< Speech::Recognition::Whisper::Response_Token >>.
Returns a L<< Speech::Recognition::Whisper::HTTPValidationError >>.

=cut

sub get_user_token( $self, %options ) {
    my $method = 'POST';
    my $path = '/api/v1/users/get_token';
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = Speech::Recognition::Whisper::User_GET_TOKEN->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::Response_Token->new($payload),

                );
            }
        } elsif( $resp->code == 422 ) {
            # Validation Error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::HTTPValidationError->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< read_user >>

  my $res = $client->read_user()->get;

Read User

=head3 Parameters

=over 4

=item B<< user_id >>

=back


Returns a L<< Speech::Recognition::Whisper::UserResponse >>.
Returns a L<< Speech::Recognition::Whisper::HTTPValidationError >>.

=cut

sub read_user( $self, %options ) {
    croak "Missing required parameter 'user_id'"
        unless exists $options{ 'user_id' };

    my $method = 'GET';
    my $template = URI::Template->new( '/api/v1/users/{user_id}/' );
    my $path = $template->process(
              'user_id' => delete $options{'user_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::UserResponse->new($payload),

                );
            }
        } elsif( $resp->code == 422 ) {
            # Validation Error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::HTTPValidationError->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< delete_user >>

  my $res = $client->delete_user()->get;

Delete User

=head3 Parameters

=over 4

=item B<< user_id >>

=back


Returns a L<< Speech::Recognition::Whisper::UserDeletedResponse >>.
Returns a L<< Speech::Recognition::Whisper::HTTPValidationError >>.

=cut

sub delete_user( $self, %options ) {
    croak "Missing required parameter 'user_id'"
        unless exists $options{ 'user_id' };

    my $method = 'DELETE';
    my $template = URI::Template->new( '/api/v1/users/{user_id}/delete' );
    my $path = $template->process(
              'user_id' => delete $options{'user_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::UserDeletedResponse->new($payload),

                );
            }
        } elsif( $resp->code == 422 ) {
            # Validation Error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::HTTPValidationError->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< update_password >>

  my $res = $client->update_password()->get;

Update Password

=head3 Parameters

=over 4

=item B<< user_id >>

=back


=head3 Options

=over 4

=item C<< current_password >>

=item C<< new_password >>

=back

Returns a L<< Speech::Recognition::Whisper::UserResponse >>.
Returns a L<< Speech::Recognition::Whisper::HTTPValidationError >>.

=cut

sub update_password( $self, %options ) {
    croak "Missing required parameter 'user_id'"
        unless exists $options{ 'user_id' };

    my $method = 'PUT';
    my $template = URI::Template->new( '/api/v1/users/{user_id}/update_password/' );
    my $path = $template->process(
              'user_id' => delete $options{'user_id'},
    );
    my $url = Mojo::URL->new( $self->server . $path );

    my $request = Speech::Recognition::Whisper::PasswordUpdate->new( \%options );
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::UserResponse->new($payload),

                );
            }
        } elsif( $resp->code == 422 ) {
            # Validation Error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::HTTPValidationError->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< ping >>

  my $res = $client->ping()->get;

Ping


Returns a L<< Speech::Recognition::Whisper::PingResponse >>.

=cut

sub ping( $self, %options ) {
    my $method = 'GET';
    my $path = '/ping';
    my $url = Mojo::URL->new( $self->server . $path );

    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # Successful Response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    Speech::Recognition::Whisper::PingResponse->new($payload),

                );
            }
        } else {
            # An unknown/unhandled response, likely an error
            return Future::Mojo->fail($resp);
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}


1;
