package AI::Ollama::Client::Impl 0.01;
# DO NOT EDIT! This is an autogenerated file.
use 5.020;
use Moo 2;
use experimental 'signatures';

# These should go into a ::Role
use YAML::PP;
use Mojo::UserAgent;
use Mojo::URL;
use Mojo::JSON 'encode_json', 'decode_json';
use OpenAPI::Modern;

use Future::Mojo;

use AI::Ollama::Error;
use AI::Ollama::NewPet;

# XXX this should be more configurable, and potentially you don't want validation?!
my $schema = YAML::PP->new( boolean => 'JSON::PP' )->load_file( 'ollama/ollama-curated.yaml' );
has 'openapi' => (
    is => 'lazy',
    default => sub { OpenAPI::Modern->new( openapi_schema => $schema, openapi_uri => '/api' )},
);

# The HTTP stuff should go into a ::Role I guess
has 'ua' => (
    is => 'lazy',
    default => sub { Mojo::UserAgent->new },
);

has 'server' => (
    is => 'lazy',
    default => sub { 'http://localhost:11434/api' }, # XXX pull from OpenAPI file instead
);

=head2 C<< findPets >>

  my $res = $client->findPets()->get;



=head3 Parameters

=item B<< tags >>

tags to filter by

=item B<< limit >>

maximum number of results to return

=cut


Returns a L<< AI::Ollama:: >>.
Returns a L<< AI::Ollama::Error >>.

=cut

sub findPets( $self, %options ) {

    my $method = 'GET';
    my $url = Mojo::URL->new( $self->server . '/pets');

              # don't know how to handle this ...
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # pet response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::->new($payload),
                );
            }
        }
        if( $resp->code == default ) {
            # unexpected error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::Error->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< addPet >>

  my $res = $client->addPet()->get;





=head3 Options

=over 4

= C<< name >>

=back

=over 4

= C<< tag >>

=back


Returns a L<< AI::Ollama::Pet >>.
Returns a L<< AI::Ollama::Error >>.

=cut

sub addPet( $self, %options ) {

    my $method = 'POST';
    my $url = Mojo::URL->new( $self->server . '/pets');

    my $request = AI::Ollama::NewPet->new( \%options );
    # resp. validate %options against NewPet
    # send as application/json
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
            "Content-Type" => 'application/json',
        }
        => json => $request->as_hash,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # pet response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::Pet->new($payload),
                );
            }
        }
        if( $resp->code == default ) {
            # unexpected error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::Error->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< deletePet >>

  my $res = $client->deletePet()->get;



=head3 Parameters

=item B<< id >>

ID of pet to delete

=cut


Returns a L<< AI::Ollama::Error >>.

=cut

sub deletePet( $self, %options ) {

    my $method = 'DELETE';
    my $url = Mojo::URL->new( $self->server . '/pets/{id}');

              # don't know how to handle this ...
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 204 ) {
            # pet deleted
            return Future::Mojo->done($resp);
        }
        if( $resp->code == default ) {
            # unexpected error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::Error->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}

=head2 C<< find_pet_by_id >>

  my $res = $client->find_pet_by_id()->get;



=head3 Parameters

=item B<< id >>

ID of pet to fetch

=cut


Returns a L<< AI::Ollama::Pet >>.
Returns a L<< AI::Ollama::Error >>.

=cut

sub find_pet_by_id( $self, %options ) {

    my $method = 'GET';
    my $url = Mojo::URL->new( $self->server . '/pets/{id}');

              # don't know how to handle this ...
    my $tx = $self->ua->build_tx(
        $method => $url,
        {
            'Accept' => 'application/json',
        }
        # XXX Need to fill the body
        # => $body,
    );

    # validate our request while developing
    my $results = $self->openapi->validate_request($tx->req);
    if( $results->{error}) {
        say $results;
        say $tx->req->to_string;
    };


    my $r1 = Future::Mojo->new();
    my $res = $r1->then( sub( $tx ) {
        my $resp = $tx->res;
        # Should we validate using OpenAPI::Modern here?!
        if( $resp->code == 200 ) {
            # pet response
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::Pet->new($payload),
                );
            }
        }
        if( $resp->code == default ) {
            # unexpected error
            my $ct = $resp->headers->content_type;
            $ct =~ s/;\s+.*//;
            if( $ct eq 'application/json' ) {
                my $payload = $resp->json();
                return Future::Mojo->done(
                    AI::Ollama::Error->new($payload),
                );
            }
        }
    });

    # Start our transaction
    $tx = $self->ua->start_p($tx)->then(sub($tx) {
        $r1->resolve( $tx );
        undef $r1;
    });

    return $res
}


1;
