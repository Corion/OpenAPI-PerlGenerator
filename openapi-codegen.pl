package main;
use 5.020;
use experimental 'signatures';
use Getopt::Long;
use Mojo::Template;
use JSON::Pointer;
use YAML::PP;

GetOptions(
    'package|p=s' => \my $package,
);

my $schema = YAML::PP->new( boolean => 'JSON::PP' )->load_file( 'ollama/ollama-curated.yaml' );

sub fixup_json_ref( $root, $curr=$root ) {
    if( ref $curr eq 'ARRAY' ) {
        for my $c ($curr->@*) {
            $c = fixup_json_ref( $root, $c );
        }

    } elsif( ref $curr eq 'HASH' ) {
        for my $k (sort keys $curr->%*) {
            if( $k eq '$ref' ) {
                my $ref = $curr->{$k};
                $ref =~ s!^#!!;

                # But we want to know its class, maybe?!

                $curr = JSON::Pointer->get($root, $ref, 1);

            } else {
                $curr->{$k} = fixup_json_ref( $root, $curr->{ $k });
            }
        };
    } else {
        # nothing to do
    }

    return $curr
}

# Fix up the schema to resolve JSON-style refs into real refs:
$schema = fixup_json_ref( $schema );

sub update_file( $filename, $content ) {
    say "## $filename";
    say $content;
}

my @methods;
my @packages;

my %template;
$template{object} = <<'__OBJECT__';
package <%= $prefix %>::<%= $name %> 0.01;
# DO NOT EDIT! This is an autogenerated file.

% for my $prop (sort keys $elt->{properties}->%*) {
%     my $p = $elt->{properties}->{$prop};
=head2 C<< <%= $prop %> >>

<%= $p->{description} =~ s/\s*$//r %>

=cut

has '<%= $prop %>' => (
    is => 'ro',
    isa => '<%= $p->{type} %>',
);

% }

1;
__OBJECT__

$template{client} = <<'__CLIENT__';
package <%= $prefix %>::<%= $name %> 0.01;
# DO NOT EDIT! This is an autogenerated file.

has 'ua' => (
    is => 'lazy',
    default => sub { Mojo::UserAgent->new },
);

% for my $method ($methods->@*) {
% my $elt = $method->{elt};
=head2 C<< <%= $method->{name} %> >>

<%= $elt->{summary} =~ s/\s*$//r %>

=cut

sub <%= $method->{name} %>( $self, %options ) {
}

% }

1;
__CLIENT__

my $mt = Mojo::Template->new->vars(1);

my %options = (
    prefix => 'AI::Ollama',
);

for my $name ( sort keys $schema->{components}->{schemas}->%*) {
    my $elt = $schema->{components}->{schemas}->{$name};
    $elt->{name} //= $name;
    my $type = $elt->{type};

    my %info = (
        %options,
        name => $name,
        type => $type,
        elt  => $elt,
    );

    if( ! exists $template{ $type}) {
        warn "No template for type '$type' ($name)";
    }
    my $template = $template{ $type };

    update_file( $name, $mt->render( $template, \%info ) );
}

# Add the methods to the main class (or, also to the current class, depending
# on tree depth?!
for my $path (sort keys $schema->{paths}->%*) {
    my $loc = $schema->{paths}->{$path};

    for my $method (sort keys $loc->%*) {
        my $elt = $loc->{$method};

        my $name = $elt->{operationId} // join "_", $path, $method;
        $name =~ s!\W!_!g;

        my %info = (
            path => $path,
            name => $name,
            method => $elt->{method},
            elt  => $elt,
        );

        push @methods, \%info;
    }
}

update_file( 'foo', $mt->render($template{client}, { methods => \@methods, name => 'Client', %options }));
